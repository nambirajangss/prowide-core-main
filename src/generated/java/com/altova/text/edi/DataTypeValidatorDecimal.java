////////////////////////////////////////////////////////////////////////
//
// DataTypeValidatorDecimal.java
//
// This file was generated by MapForce 2025.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import java.lang.Double;
import com.altova.text.ITextNode;

public class DataTypeValidatorDecimal extends DataTypeValidator {

	int mImplicitDecimals;

	public DataTypeValidatorDecimal (int minLength, int maxLength, int implicitDecimals) {
		super (minLength, maxLength, null);
		mImplicitDecimals = implicitDecimals;
	}

	private boolean checkNumber( String s) {
		return s.matches("^[+-]?[0-9]*(\\.[0-9]*)?$");
	}
	
	public boolean compare(String s1, String s2) { return Double.compare( Double.parseDouble(s1), Double.parseDouble(s2) ) == 0; }

	public boolean makeValidOnRead (StringBuffer s, Parser.Context context, Scanner.State beforeRead) {

		char dec = context.getScanner().getServiceChars().getDecimalSeparator();

		int effLen = effectiveLengthDecimal(s, dec);
		validateLength(effLen, s.toString(), context, beforeRead);

		String str = s.toString().trim();
		
		
		if (str.length() == 0) {
			context.handleError(
					Parser.ErrorType.FieldValueInvalid,
					new ErrorPosition( beforeRead ),
					ErrorMessages.GetInvalidFieldValueMessage(
						context.getParticle().getNode().getName(),
						s.toString(),
						"decimal"
					),
					s.toString()
				);
			return true;
		}
		
		s.replace(0, s.length(), str);
		
		if (mImplicitDecimals > 0) {
			boolean bNegativ = false;
			
			if ((bNegativ = s.charAt(0) == '-') || s.charAt(0) == '+') {
				s.delete(0, 1);
			}

			if (effLen < mImplicitDecimals)
				for (int i=0; i< mImplicitDecimals - effLen; ++i)
					s.insert(0, '0');

			s.insert(s.length()- mImplicitDecimals, '.');
			if (bNegativ)
				s.insert(0, '-');
		} else {
			for (int i=0; i<s.length(); ++i)
				if (s.charAt(i) == dec || s.charAt(i) == ',')
					s.setCharAt(i, '.');
			if (s.charAt(0) == '.')
				s.insert(0, '0');
		}
		
		if (!checkNumber(s.toString())) {
			context.handleError(
					Parser.ErrorType.FieldValueInvalid,
					new ErrorPosition( beforeRead ),
					ErrorMessages.GetInvalidFieldValueMessage(
						context.getParticle().getNode().getName(),
						s.toString(),
						"decimal"
					),
					s.toString()
				);
		}
		
		return true;
	}

	public boolean makeValidOnWrite (StringBuffer s, ITextNode node, Writer writer, boolean esc) {
		return makeValidOnWrite(s, node, writer);
	}

	public boolean makeValidOnWrite (StringBuffer s, ITextNode node, Writer writer) {
		trimLeft(s, ' ');
		trimRight(s, ' ');
		if (writer.getEDIKind() == EDISettings.EDIStandard.EDIFixed) {
			if (s.length() == 0) {
				padRight(s, '0', getMaxLength());
				return true;
			}
		}
		else {
			if (s.length() == 0) {
				return true;
			}
		}
		
		boolean negative = false;
		
		if (s.charAt(0) == '+' || s.charAt(0) == '-') {
			negative = s.charAt(0) == '-';
			s.deleteCharAt(0);
		}
		
		if (s.length() == 0) return false;
		
		if (s.indexOf(Character.toString(writer.getServiceChars().getDecimalSeparator())) != -1)
			s.setCharAt(s.indexOf(Character.toString(writer.getServiceChars().getDecimalSeparator())), '.');
		
		java.math.BigDecimal d = new java.math.BigDecimal(s.toString());

		if (mImplicitDecimals > 0) {
			d = d.setScale(mImplicitDecimals, java.math.RoundingMode.HALF_UP);
			s.setLength(0);
			s.append(d.toString());
		} else {
			s.setLength(0);
			s.append(d.toString());
			int effLen = effectiveLength(s, '.'); 
			if (effLen > getMaxLength()) {
				int pos = s.indexOf(".");
				if (pos != -1 && pos < getMaxLength()) {
					int newScale = Math.max(getMaxLength() - pos + 1, 0);
					d = d.setScale(newScale, java.math.RoundingMode.HALF_UP);
					s.setLength(0);
					s.append(d.toString());
				}
			}
		}

		StringBuffer integral = new StringBuffer();
		StringBuffer fractional = new StringBuffer();
		
		if (s.indexOf(".") != -1) {
			integral.append(s.subSequence(0, s.indexOf(".")));
			fractional.append(s.subSequence(s.indexOf(".")+1, s.length()));
		}
		else {
			integral.append(s);
		}

		trimLeft(integral, '0');
		if (writer.getEDIKind() != EDISettings.EDIStandard.EDIX12 || mImplicitDecimals > 0) {
			if (integral.length() == 0)
				integral.append('0');
		}
		
		trimRight(fractional, '0');
		
		if (mImplicitDecimals > 0) {
			padRight(fractional, '0', mImplicitDecimals - fractional.length());
		}
		else {
			if (fractional.length() > 0)
				fractional.insert(0,  '.');
		}
		
		if (writer.getEDIKind() == EDISettings.EDIStandard.EDIFixed) {
			padLeft(integral, '0', getMaxLength() - integral.length() - fractional.length() - (negative ? 1 : 0));
		}
		else {
			if (getMinLength() > integral.length() + fractional.length() + (negative ? 1 : 0)) {
				padLeft(integral, '0', getMinLength() - integral.length() - fractional.length() - (negative ? 1 : 0));
			}
		}
		
		s.setLength(0);
		if (negative) {
			s.append('-');
		}
		s.append(integral);
		s.append(fractional);
		
		if (s.indexOf(".") != -1)
			s.setCharAt(s.indexOf("."), writer.getServiceChars().getDecimalSeparator());
		
		int effLen = effectiveLength(s, writer.getServiceChars().getDecimalSeparator());
		//report error/warning
		validateLength(effLen, s.toString(), node, writer);
		
		if (writer.getEDIKind() == EDISettings.EDIStandard.EDIFixed) {
			if (s.length() > getMaxLength()) {
				s.delete(getMaxLength(), s.length());
			}
		}
		return true;
	}

	int effectiveLengthDecimal(StringBuffer s, char decimalMark) {
		int len = s.length();

		for (int i=0; i< s.length(); ++i)
			if ((decimalMark != 0 && s.charAt(i) == decimalMark) || s.charAt(i) == '.' || s.charAt(i) == ',' || s.charAt(i) == '-')
				--len;

		return len;
	}
}
