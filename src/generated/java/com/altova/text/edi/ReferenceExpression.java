////////////////////////////////////////////////////////////////////////
//
// ReferenceExpression.java
//
// This file was generated by MapForce 2025.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import com.altova.text.ITextNode;
import java.util.function.Function;
import java.util.Vector;

public class ReferenceExpression extends DataExpression {
	protected Function<String, Boolean> mNameFn;
	protected Function<String, Boolean> mNodeFn;
	protected Function<String, Boolean> mPathFn;
	
	public ReferenceExpression(Function<String, Boolean> nameFn, Function<String, Boolean> nodeFn) {
		super(new DataExpression[]{});
		this.mNameFn = nameFn;
		this.mNodeFn = nodeFn;
		this.mPathFn = null;
	}
	public ReferenceExpression(Function<String, Boolean> pathFn) {
		super(new DataExpression[]{});
		this.mNameFn = null;
		this.mNodeFn = null;
		this.mPathFn = pathFn;
	}

	public String evaluate(ITextNode node) {
		ITextNode res = null;
		if (mPathFn != null) {
			ITextNode rootNode = node;
			while (rootNode.getParent() != null)
				rootNode = rootNode.getParent();

			res = findByPath(rootNode, node, "");
			if (res != null && res != node)
				return res.getValue();
		}
		else {
			ITextNode rootNode = node;
			while (rootNode.getParent() != null && !mNodeFn.apply(rootNode.getName()))
				rootNode = rootNode.getParent();

			for (int i = 0; i < rootNode.getChildren().size(); ++i) {
				res = findByName(rootNode.getChildren().getAt(i));
				if (res != null)
					return res.getValue();
			}
		}

		return "";
	}
	protected ITextNode findByName(ITextNode node) {
		if (mNameFn.apply(node.getName())) return node;

		for (int i = 0; i < node.getChildren().size(); ++i) {
			ITextNode res = findByName(node.getChildren().getAt(i));
			if (res != null)
				return res;
		}

		return null;
	}
	protected ITextNode findByPath(ITextNode node, ITextNode origin, String path) {
		if (node == origin)
			return origin; // stop after reaching the start node - only complete based on nodes written before

		if (path.length() > 0) path += "/";
		path += node.getName();

		ITextNode found = null;
		if (mPathFn.apply(path))
			found = node;

		for (int i = 0; i < node.getChildren().size(); ++i) {
			ITextNode res = findByPath(node.getChildren().getAt(i), origin, path);
			if (res != null) {
				if (res != origin)
					found = res;
				else
					break;
			}
		}

		return found;
	}
	public boolean matchesParticles(Vector<Particle> path) {
		if (mPathFn != null) {
			StringBuilder spath = new StringBuilder();
			for (Particle p : path) {
				if (spath.length() > 0)
					spath.append("/");
				spath.append(p.getName());
			}
			return mPathFn.apply(spath.toString());
		}
		else {
			if (mNameFn.apply(path.lastElement().getName())) {
				for (Particle p : path) {
					if (mNodeFn.apply(p.getName()))
						return true;
				}
			}
		}
		return false;
	}

	public boolean matchesNodes(Vector<ITextNode> path)
	{
		if (mPathFn != null) {
			StringBuilder spath = new StringBuilder();
			for (ITextNode n : path) {
				if (spath.length() > 0)
					spath.append("/");
				spath.append(n.getName());
			}
			return mPathFn.apply(spath.toString());
		}
		else {
			if (mNameFn.apply(path.lastElement().getName())) {
				for (ITextNode n : path) {
					if (mNodeFn.apply(n.getName()))
						return true;
				}
			}
		}
		return false;
	}
	
	public boolean matchesNodes(ITextNode node)
	{
		if (mPathFn != null) {
			StringBuilder spath = new StringBuilder();
			while (node != null) {
				if (spath.length() > 0)
					spath.insert(0, "/");
				spath.insert(0, node.getName());
				node = node.getParent();
			}
			return mPathFn.apply(spath.toString());
		}
		else {
			if (mNameFn.apply(node.getName())) {
				node = node.getParent();
				while (node != null) {
					if (mNodeFn.apply(node.getName()))
						return true;
					node = node.getParent();
				}
			}
		}
		return false;
	}
}
