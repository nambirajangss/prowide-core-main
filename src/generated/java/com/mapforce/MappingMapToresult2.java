/**
 * MappingMapToresult2.java
 *
 * This file was generated by MapForce 2025r2.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */
package com.mapforce;
import com.altova.mapforce.*;
import com.altova.types.*;
import com.altova.xml.*;
import com.altova.text.tablelike.*;
import com.altova.text.*;
import com.altova.text.edi.*;
import java.util.*;

public class MappingMapToresult2 extends com.altova.TraceProvider {
	private boolean runDoesCloseAll = true;
	public void setCloseObjectsAfterRun(boolean c) {runDoesCloseAll = c;}
	public boolean getCloseObjectsAfterRun() {return runDoesCloseAll;}


	static class Main implements IEnumerable {

		public Main()	{
		}

		public IEnumerator enumerator() {return new Enumerator(this);}

		public static class Enumerator implements IEnumerator {
			int pos = 0;
			int state = 2;
			Object current;
			Main closure;
			double var1_cast;

			public Enumerator(Main closure) {
				this.closure = closure;
			}

			public Object current() {return current;}

			public int position() {return pos;}

			public boolean moveNext() throws Exception {
				while (state != 0) {
					switch (state) {
						case 2: if (moveNext_2()) return true; break;
					}
				}
				return false;
			}

			private boolean moveNext_2() throws Exception {
				state = 0;				
				var1_cast = com.altova.CoreTypes.parseDouble("2");
				current = com.altova.functions.Core.concat(com.altova.functions.Core.concat("9999-12-31T00:00:00", "+"), com.altova.functions.Core.concat(com.altova.functions.Core.concat(com.altova.functions.Core.substring("0000", com.altova.CoreTypes.parseDouble("1"), var1_cast), ":"), com.altova.functions.Core.substring("0000", com.altova.CoreTypes.parseDouble("3"), var1_cast)));
				pos++;
				return true;
			}


			public void close() {
			}
		}
	}
	static class Outer implements IEnumerable {

		public Outer()	{
		}

		public IEnumerator enumerator() {return new Enumerator(this);}

		public static class Enumerator implements IEnumerator {
			int pos = 0;
			int state = 1;
			Object current;
			Outer closure;
			IEnumerator var1_cast;

			public Enumerator(Outer closure) {
				this.closure = closure;
			}

			public Object current() {return current;}

			public int position() {return pos;}

			public boolean moveNext() throws Exception {
				while (state != 0) {
					switch (state) {
						case 1: if (moveNext_1()) return true; break;
						case 2: if (moveNext_2()) return true; break;
						case 3: if (moveNext_3()) return true; break;
					}
				}
				return false;
			}

			private boolean moveNext_1() throws Exception {
				state = 2;				
				var1_cast = ((new Main())).enumerator();
				return false;
			}
			private boolean moveNext_2() throws Exception {
				state = 2;				
				if (!var1_cast.moveNext()) {state = 3; return false; }
				current = var1_cast.current();
				pos++;
				return true;
			}
			private boolean moveNext_3() throws Exception {
				state = 0;				
				if( var1_cast != null ) { var1_cast.close(); var1_cast = null; }
				return false;
			}


			public void close() {
				try {
					if( var1_cast != null ) { var1_cast.close(); var1_cast = null; }
				} catch (Exception e) {
				}
			}
		}
	}


	// instances


	// main entry point

	public String run() throws Exception {
		try {
			// Open the source(s)

			// Create the target

			// Execute mapping

			Main mapping = new Main();

			String varresult2TargetParameter = com.altova.functions.Core.last(mapping).toString();
			
			// Close the target

			return varresult2TargetParameter;

		}
		finally {

			if (runDoesCloseAll) {
			}

		}
	}


}
